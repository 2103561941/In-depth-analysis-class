/*
通过上个例子，我们了解到了内存对齐是什么，以及通过一个简单的程序算出了系统分配的默认内存对齐大小
补充说明，内存对齐是因为这块内存不能塞在别的地方了，只能再开一块大小，通过补齐内存分配给它
但是对于int + char + char 来说， 两个char的地址是可以塞在同一块补齐块里面的， 所以这块内存的大小还是8 （还可以再加两个char）
虽然编译器可以通过塞元素来节约内存，但是不能把一个变量的内存拆分放到两个补齐块里。
但这不是绝对的，除非变量要求的大小比补齐块还大，好比上一个程序里的64位空间的结构体，它会被分配到8个连续的补齐块了里。 下面进行举例。

接下来我将写几个典型的例子来给大伙计算一波
*/

#include <iostream>

using namespace std;

// 内存插入的对照组
class Mul_C_I {
    int x;
    char c;
};

class Mul_2C_I {
    int x;
    char c1, c2;
};


/*
这里给出一个新的知识点，编译器不会聪明到对类里面的内存进行排列操作，使得他们能够很好的进行组合塞入一块补齐块里，
而是按照类里面的变量声明的顺序分配大小，上面也讲了同一个变量不能拆分成两块分配到两块补齐块里， 
所以就会产生下面这种里面元素一样，但是因为声明顺序的变化而产生内存分配大小不一致的问题， 
通过这个，我们可以合理设计类元素的声明顺序从而达到节约空间分配的问题。(我试过O2,O3 的优化等级，编译器并没有解决这个问题)
*/

class Mul_I_P_I {
    int x;   
    void* p;
    int y;
};


class Mul_P_2I {
    void* p;
    int x, y;
};

void getClassSize() {
    //1.
    printf("Mul_C_I = %d\n", sizeof(Mul_C_I));      // 4 + 1 + (3) = 8
    printf("Mul_2C_I = %d\n", sizeof(Mul_2C_I));    // 4 + 1 + 1 + (2) = 8
    //2.
    printf("Mul_I_P_I = %d\n", sizeof(Mul_I_P_I));    // 4 + (4) + 8 + 4 + (4) = 24
    printf("Mul_P_2I = %d\n", sizeof(Mul_P_2I));    // 8 + 4 + 4 = 16
}


int main() {
    getClassSize();

}
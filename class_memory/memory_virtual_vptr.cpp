/*
前面我一直在回避父类中包含虚函数的继承这个条件，因为加上这个条件之后，会引入一些新的内容，并且改变了类中的内存结构
下面我将尽可能理清思路，带你拨开虚函数继承神秘的面纱（虚函数继承不等于虚继承，虚继承会涉及更复杂的内容，本次RTTI的探索之旅暂且不会提及）
*/

/*
在剖析虚函数继承类的内存结构前，我们需要向你介绍什么虚函数关于内存的提出的虚函数表和虚指针的内容，以及他们在内存中的结构
（有关虚函数实现多态的剖析不放在这里讲解，尽量保持内容的独立性，虚函数的相关语法这里也不讲了）

对于存在虚函数的类，编译器会为其生成一张虚函数表（本质是一个数组，存放函数指针），为什么不会像成员函数一样直接放公开的空间，在继承多态的章节会讲。
虚函数表里不仅存放虚函数指针，同样存放着一个type_info 结构体（这个东西会在RTTI里面使用）一般会在虚函数的[-1]的位置，也看编译器

由于每个包含虚函数的类不是直接保存一张虚函数表的，而是一个指向虚函数表头的指针，所以我为了简化流程，先对虚函数指针进行剖析
虚函数指针一般存放在类的第一个位置，这就是我之前说的类在有虚函数后内存结构发生的细微的变化。


----------------声明--------------
不同平台、不同编译器厂商所生成的虚表指针在内存中的布局是不同的，有些将虚表指针置于对象内存中的开头处，有些则置于结尾处。
如果涉及多重继承和虚继承，情况还将更加复杂。基于此，永远不要做任何假设，永远不要使用memcpy()之类的函数复制对象，
而应该使用初始化（构造和拷构）或赋值的方式来复制对象。

但是对于主流的编译器来说虚函数指针是存放在第一位的，（c++prime里面也说了其是放在内存开头的位置，所以）

*/

#include <iostream>

using namespace std;

class Vir {
    virtual void show() {}
};

class Vir_I {
    virtual void show() {}
    int x;
};


void getClassSize() {
    printf("Vir = %d\n", sizeof(Vir)); // 8 (sizeof(vptr))
    printf("Vir_I = %d\n", sizeof(Vir_I)); // 8 + 4 + (4) = 16
}


int main() {

    getClassSize();

}
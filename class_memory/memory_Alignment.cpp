/*
内存对齐可以使处理器处理速度加快，使内存的逻辑调度单元变得简单（他不用知道从哪里开始有哪个变量，因为变量的开始是整数倍的, 这块我不做深入了解）

每个平台和编译器都有属于自己的默认对齐字节数 我所使用的gcc可以通过#pragma pack(int) 的宏来指定大小
而类中的对齐有效位是选择 给定值#pragma pack(n) 和 结构体中最长数据类型长度 中较小的那个
举个例子， 我的pack是4， 而我设计的类里面最大的类型是long long （8）， 这时候对齐有效位就是4。

下面我对计算内存的算式中会把内存对齐的大小用括号括起来， 比如 char + int = 1 + (3) + 4 = 8 
*/

// #pragma pack(4) ， 这里我把默认对齐大小改成4，对于GetM 里的默认大小也会改变
#include <iostream>

using namespace std;

// 先做个简单的测试查看我当前使用的编译器的默认内存对齐位是多少
// 这里设计一个占64位的结构体，这样可以通过 char 的内存对齐，只要结构体大于默认内存对齐大小，char就会跟默认大小对齐，从而得到编译器默认的内存对齐

struct node {
    double m[8]; // 64 
};

class GetM {
    char s; // 1
    node m; // 64 
};


int main() {
    printf("GetM = %d\n", sizeof(GetM));  // 64 + 1 + (7) = 72
    printf("node + char = 64 + 1 + (7), get the pack is 8\n"); // 得到默认值为8
}

